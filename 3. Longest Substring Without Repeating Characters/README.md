- 因为要求出最大长度，必然需要一个trace变量来保存这个长度，如果滑动窗口统计出来了这个长度之后，比较之前的长度，如果是更大的值，则需要更新这个trace。
- 然后是这个题目的核心，滑动窗口。滑动窗口就是左右两个指针作为边界指针。首先左边不动，右边一直滑动，如果遇到有重复的元素，则左侧的指针开始向右滑动，一直滑动到没有重复元素位置，而且滑动不超过右侧指针。这每一次过程中，记录下来这个滑动窗口曾经有过的最大长度。
- 中间保存没有重复的元素集合，考虑Set类型数据结构。
- 注意： 关于滑动窗口，这里分为两个分支，就这道题目来说，有如下两种滑动窗口思维，先表明，第二种个人命名为伸缩窗口（滑动窗口的延伸） 
  - a. 官方题解中的滑动窗口思路
    - ⅰ. 官方题解中的滑动窗口思路。其实是先固定最左侧游标，然后右游标一次一个个char往下走。如果遇到有重复的，停止走，记录长度，且保留最大长度于临时变量中。然后开始下一轮遍历；
    - ⅱ. 下一轮开始时候，左侧游标开始右移动一个位置，然后右侧游标又开始一次往下走。同样是遇到重复停下来，记录此刻长度，比较之后，保留最大长度值于临时变量； 
    - ⅲ. 依次类推，一直到左侧游标走完整个字符串到达最右端。同时每一轮回中最大长度的值已经被保存下来。 
  - b. 优化之后的伸缩窗口思路，比官方解题思路效率更高 1）
    - ⅰ. 不区分左右两游标，我们另取名为不重复字符串的起始游标，简称起始游标。以及不断向右一个个char移动的移动游标。（如果硬要类比的话，起始游标相当于上面思路的左游标，移动游标相当于右游标）； 
    - ⅱ. 这里有一个小trick，就是上面思路中，我们如果利用，比如说golang的map数据结构，实际上我们只利用了map中key必须唯一的特性。实际上map的value具体是什么，是没用的。但是在这个思路里面，我们将要利用这个value, 我们利用这个value 来作为当前char在string中的index。这样我门就不需要另外一个变量来保存这个index了。说白了，就是将string，一个数组，转换成了map，这个map的key是每个char，value是该char的index。 
    - ⅲ. 我们将起始游标放在-1的位置上，注意并不是0的起始位置上，为什么这么作呢。因为这样是为了方便我们计算不重复字符串的长度。举例说明下。假如说字符串是"aabcd"，第二个字符串就开始重复了。那么起始游标在-1,移动游标在1，我们的map中，已经保存了一个map["a"]=0, 那么我现在想知道这个可怜的不重复字符串的长度是多少呢？就用map["a"] = 0, 去减去起始游标的-1,就得到了长度1。这算是一个小技巧把。根本原因在于，我们计算机通常index是从0开始计数。 
    - ⅳ. 现在从头开始正常过一边。起始游标处于-1, 也就是string第一个char ， index=0的左侧。 
    - ⅴ. 然后移动游标开始一个个char向右侧移动。每移动一个char，先判断这个char在不在已经存在的map的keys当中：如果不在，就把该char和对应的index放入map中，然后用index减去起始游标，就得到长度，把长度更新到临时变量中去，当然保存最大值；如果在，要做几个事情
      - 1. 第一个要保证此时的该char在string的index是大于起始游标的。
      - 2. 然后第二个事情，将起始游标的位置等于map["same char"]已经保存过，也就是碰到重复事件前最前一次出现的index，也就是起始游标开始移动到了被重复的char的index位置了；
      - 3. 然后第三个事情，我们把已经存在的map["same char"]的index，更新到这个当前loop里面这个重复char的最新index。（也就是说，这个map中，最后时候将会只保存所有重复的char的最大的index值）；注意，这里第二个事情和第三个事情顺序不可以颠倒。 
    - ⅵ. 如果比喻一下的话，这个过程就好像毛毛虫那样伸缩伸缩的毛毛虫一样前进，故我取名为滑动窗口的变种，伸缩窗口
